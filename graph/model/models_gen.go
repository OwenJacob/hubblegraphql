// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type Account struct {
	ID              string         `json:"id"`
	Sequence        string         `json:"sequence"`
	HomeDomain      string         `json:"homeDomain"`
	NativeBalance   string         `json:"nativeBalance"`
	MasterWeight    int            `json:"masterWeight"`
	LowThreshold    int            `json:"lowThreshold"`
	MediumThreshold int            `json:"mediumThreshold"`
	HighThreshold   int            `json:"highThreshold"`
	Flags           *Flags         `json:"flags"`
	Balances        []*Balance     `json:"balances"`
	Signers         []*Signer      `json:"signers"`
	Data            []*Data        `json:"data"`
	Transactions    []*Transaction `json:"transactions"`
}

type AccountFilter struct {
	PubKey    string              `json:"pubKey"`
	Direction AccountFilterOption `json:"direction"`
}

type Balance struct {
	Balance            string `json:"balance"`
	BuyingLiabilities  string `json:"buyingLiabilities"`
	SellingLiabilities string `json:"sellingLiabilities"`
	Limit              string `json:"limit"`
	LastModifiedLedger int    `json:"lastModifiedLedger"`
	IsAuthorized       bool   `json:"isAuthorized"`
	AssetCode          string `json:"assetCode"`
	AssetIssuer        string `json:"assetIssuer"`
}

type Data struct {
	Name  *string `json:"name"`
	Value *string `json:"value"`
}

type DateFilter struct {
	FromDate string `json:"fromDate"`
	ToDate   string `json:"toDate"`
}

type FilterBy struct {
	Account *AccountFilter `json:"account"`
	Date    *DateFilter    `json:"date"`
	Ledger  *LedgerFilter  `json:"ledger"`
}

type Flags struct {
	AuthRequired  bool `json:"authRequired"`
	AuthRevocable bool `json:"authRevocable"`
	AuthImmutable bool `json:"authImmutable"`
}

type Ledger struct {
	Sequence                   int            `json:"sequence"`
	LedgerHash                 string         `json:"ledgerHash"`
	PreviousLedgerHash         *string        `json:"previousLedgerHash"`
	TransactionCount           int            `json:"transactionCount"`
	OperationCount             int            `json:"operationCount"`
	ClosedAt                   string         `json:"closedAt"`
	CreatedAt                  *string        `json:"createdAt"`
	UpdatedAt                  *string        `json:"updatedAt"`
	ID                         *int           `json:"id"`
	ImporterVersion            int            `json:"importerVersion"`
	TotalCoins                 string         `json:"totalCoins"`
	FeePool                    string         `json:"feePool"`
	BaseFee                    int            `json:"baseFee"`
	BaseReserve                int            `json:"baseReserve"`
	MaxTxSetSize               int            `json:"maxTxSetSize"`
	ProtocolVersion            int            `json:"protocolVersion"`
	LedgerHeader               *string        `json:"ledgerHeader"`
	SuccessfulTransactionCount *int           `json:"successfulTransactionCount"`
	FailedTransactionCount     *int           `json:"failedTransactionCount"`
	Transactions               []*Transaction `json:"transactions"`
}

type LedgerFilter struct {
	FromNumber int `json:"fromNumber"`
	ToNumber   int `json:"toNumber"`
}

type Operation struct {
	ID               string  `json:"id"`
	TransactionID    string  `json:"transactionID"`
	ApplicationOrder int     `json:"applicationOrder"`
	Type             int     `json:"type"`
	Details          *string `json:"details"`
	SourceAccount    string  `json:"sourceAccount"`
}

type Signer struct {
	Weight int    `json:"weight"`
	Key    string `json:"key"`
}

type Transaction struct {
	TransactionHash      string       `json:"transactionHash"`
	LedgerSequence       int          `json:"ledgerSequence"`
	ApplicationOrder     int          `json:"applicationOrder"`
	Account              string       `json:"account"`
	AccountSequence      string       `json:"accountSequence"`
	MaxFee               string       `json:"maxFee"`
	OperationCount       int          `json:"operationCount"`
	CreatedAt            *string      `json:"createdAt"`
	UpdatedAt            *string      `json:"updatedAt"`
	ID                   *string      `json:"id"`
	TxEnvelope           string       `json:"txEnvelope"`
	TxResult             string       `json:"txResult"`
	TxMeta               string       `json:"txMeta"`
	TxFeeMeta            string       `json:"txFeeMeta"`
	Signatures           []string     `json:"signatures"`
	MemoType             string       `json:"memoType"`
	Memo                 *string      `json:"memo"`
	TimeBounds           []*int       `json:"timeBounds"`
	Successful           *bool        `json:"successful"`
	FeeCharged           *string      `json:"feeCharged"`
	InnerTransactionHash *string      `json:"innerTransactionHash"`
	FeeAccount           *string      `json:"feeAccount"`
	InnerSignatures      []*string    `json:"innerSignatures"`
	NewMaxFee            *string      `json:"newMaxFee"`
	Operations           []*Operation `json:"operations"`
}

type AccountFilterOption string

const (
	AccountFilterOptionAll  AccountFilterOption = "all"
	AccountFilterOptionFrom AccountFilterOption = "from"
	AccountFilterOptionTo   AccountFilterOption = "to"
)

var AllAccountFilterOption = []AccountFilterOption{
	AccountFilterOptionAll,
	AccountFilterOptionFrom,
	AccountFilterOptionTo,
}

func (e AccountFilterOption) IsValid() bool {
	switch e {
	case AccountFilterOptionAll, AccountFilterOptionFrom, AccountFilterOptionTo:
		return true
	}
	return false
}

func (e AccountFilterOption) String() string {
	return string(e)
}

func (e *AccountFilterOption) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountFilterOption(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountFilterOption", str)
	}
	return nil
}

func (e AccountFilterOption) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Order string

const (
	OrderAsc  Order = "asc"
	OrderDesc Order = "desc"
)

var AllOrder = []Order{
	OrderAsc,
	OrderDesc,
}

func (e Order) IsValid() bool {
	switch e {
	case OrderAsc, OrderDesc:
		return true
	}
	return false
}

func (e Order) String() string {
	return string(e)
}

func (e *Order) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Order(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Order", str)
	}
	return nil
}

func (e Order) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
